using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// This script is supposed to simulate all offscreen asteroids to save processing power, since unity colliders are expensive
/// </summary>
public class AsteroidSimulator : MonoBehaviour
{
    [SerializeField] private int gridLength;
    [SerializeField] private int gridWidth;

    [SerializeField] private float minSpeed;
    [SerializeField] private float maxSpeed;

    private int _idCounter;

    private Asteroid _asteroidToSpawn = new Asteroid();

    // Asteroid master list, probably TODO: remove later.
    private List<Asteroid> _allAsteroids = new List<Asteroid>();

    // Creating 5 different groups of asteroids so I can split checking them into different physics ticks.
    private List<Asteroid> _asteroidGroup1 = new List<Asteroid>();
    private List<Asteroid> _asteroidGroup2 = new List<Asteroid>();
    private List<Asteroid> _asteroidGroup3 = new List<Asteroid>();
    private List<Asteroid> _asteroidGroup4 = new List<Asteroid>();
    private List<Asteroid> _asteroidGroup5 = new List<Asteroid>();
    private List<Asteroid> _asteroidListForAddingToDict = new List<Asteroid>();

    private Vector2Int _northChunkCoordinates = new Vector2Int();
    private Vector2Int _southChunkCoordinates = new Vector2Int();
    private Vector2Int _eastChunkCoordinates = new Vector2Int();
    private Vector2Int _westChunkCoordinates = new Vector2Int();

    private Vector2Int _northEastChunkCoordinates = new Vector2Int();
    private Vector2Int _southEastChunkCoordinates = new Vector2Int();
    private Vector2Int _northWestChunkCoordinates = new Vector2Int();
    private Vector2Int _southWestChunkCoordinates = new Vector2Int();

    // Chunks with coordinates and a list of all asteroids in them
    private Dictionary<Vector2Int, List<Asteroid>> _allChunks = new Dictionary<Vector2Int, List<Asteroid>>();


    private void Start()
    {
        _idCounter = 0;
        for (int i = 0; i < gridLength; i++)
        {
            for (int j = 0; j < gridWidth; j++)
            {
                _asteroidToSpawn = new Asteroid(Random.Range(minSpeed, maxSpeed),
                                                new Vector2(i - gridLength / 2, j - gridWidth / 2),
                                                new Vector2(Random.Range(-1f, 1f), Random.Range(-1f, 1f)).normalized,
                                                _idCounter,
                                                false);

                _idCounter++;

                // First we add the asteroid to its chunk's list.
                if (_allChunks.ContainsKey(_asteroidToSpawn.ChunkCoordinates))
                {
                    _allChunks[_asteroidToSpawn.ChunkCoordinates].Add(_asteroidToSpawn);
                }
                else
                {
                    _asteroidListForAddingToDict = new List<Asteroid>();
                    _asteroidListForAddingToDict.Add(_asteroidToSpawn);
                    _allChunks.Add(_asteroidToSpawn.ChunkCoordinates, _asteroidListForAddingToDict);
                }

                // Now we determine the group the asteroid should go into.
                _allAsteroids.Add(_asteroidToSpawn);
            }
        }

        StartCoroutine(CheckForNewChunk(0.1f));
        StartCoroutine(CheckCollisionWithinChunk(0.1f));
    }

    private void Update()
    {
        // test data
        Asteroid nearest = new Asteroid(1, Vector2.down, Vector2.down, 999999, false);
        //for (int i = 0; i < _allAsteroids.Count; i++)
        //{
        //    _allAsteroids[i].Position += _allAsteroids[i].Direction * _allAsteroids[i].Speed * Time.deltaTime;
        //}

    }

    private void FixedUpdate()
    {
        for (int i = 0; i < _allAsteroids.Count; i++)
        {
            _allAsteroids[i].Position += _allAsteroids[i].Direction * _allAsteroids[i].Speed * Time.fixedDeltaTime;
        }
    }

    /// <summary>
    /// TODO: 
    /// </summary>
    /// <param name="refireDelay"></param>
    /// <returns></returns>
    private System.Collections.IEnumerator CheckForNewChunk(float refireDelay)
    {
        var wait = new WaitForSeconds(refireDelay);
        while (true)
        {
            for (int i = 0; i < _allAsteroids.Count; i++)
            {
                if (_allAsteroids[i].HasEnteredNewChunk())
                {
                    if (_allChunks.ContainsKey(_allAsteroids[i].ChunkCoordinates))
                    {
                        _allChunks[_allAsteroids[i].ChunkCoordinates].Add(_allAsteroids[i]);
                    }
                    else
                    {
                        _asteroidListForAddingToDict = new List<Asteroid>();
                        _asteroidListForAddingToDict.Add(_allAsteroids[i]);
                        _allChunks.Add(_allAsteroids[i].ChunkCoordinates, _asteroidListForAddingToDict);
                    }

                    _allChunks[_allAsteroids[i].PreviousChunkCoordinates].Remove(_allAsteroids[i]);
                    _allAsteroids[i].UpdatePreviousChunkCoordinates();
                }
            }
            yield return wait;
        }
    }

    // TODO: need to check collision within neighbouring chunks as well - figure out optimal way of getting neighbour chunks
    /// <summary>
    /// TODO: 
    /// </summary>
    /// <param name="refireDelay"></param>
    /// <returns></returns>
    private System.Collections.IEnumerator CheckCollisionWithinChunk(float refireDelay)
    {
        var wait = new WaitForSeconds(refireDelay);
        while (true)
        {
            for (int i = 0; i < _allAsteroids.Count; i++)
            {
                for (int j = 0; j < _allChunks[_allAsteroids[i].ChunkCoordinates].Count; j++)
                {
                    if ((_allAsteroids[i].Position - _allChunks[_allAsteroids[i].ChunkCoordinates][j].Position).magnitude < 0.3f)
                    {
                        //Debug.Log("Asteroids " + _allAsteroids[i].Id + " and " + _allChunks[_allAsteroids[i].ChunkCoordinates][j].Id + " have been destroyed.");
                    }
                }

                CheckOrthogonallyNeighbouringChunks(_allAsteroids[i].ChunkCoordinates, i);
                //CheckDiagonallyNeighbouringChunks(_allAsteroids[i].ChunkCoordinates, i);
            }
            yield return wait;
        }
    }

    /// <summary>
    /// TODO: 
    /// </summary>
    /// <param name="chunkCoordinates"></param>
    /// <param name="i"></param>
    private void CheckOrthogonallyNeighbouringChunks(Vector2Int chunkCoordinates, int i)
    {
        int testCounter = 0;

        _northChunkCoordinates = chunkCoordinates;
        _northChunkCoordinates.y = chunkCoordinates.y + 1;

        _southChunkCoordinates = chunkCoordinates;
        _southChunkCoordinates.y = chunkCoordinates.y - 1;

        _eastChunkCoordinates = chunkCoordinates;
        _eastChunkCoordinates.x = chunkCoordinates.x + 1;

        _westChunkCoordinates = chunkCoordinates;
        _westChunkCoordinates.x = chunkCoordinates.x - 1;

        List<Asteroid> asteroidList;

        // Dictionary optimization - TryGetValue does 1 lookup, ContainsKey does 2.
        if (_allChunks.TryGetValue(_northChunkCoordinates, out asteroidList))
        {
            for (int j = 0; j < asteroidList.Count; j++)
            {
                if (CheckCollision(_allAsteroids[i].Position, asteroidList[j].Position))
                {
                    //Debug.Log("Asteroids " + _allAsteroids[i].Id + " and " + _allChunks[_allAsteroids[i].ChunkCoordinates][j].Id + " have been destroyed.");
                }
            }
        }

        if (_allChunks.TryGetValue(_southChunkCoordinates, out asteroidList))
        {
            for (int j = 0; j < asteroidList.Count; j++)
            {
                if (CheckCollision(_allAsteroids[i].Position, asteroidList[j].Position))
                {
                    //Debug.Log("Asteroids " + _allAsteroids[i].Id + " and " + _allChunks[_allAsteroids[i].ChunkCoordinates][j].Id + " have been destroyed.");
                }
            }
        }

        if (_allChunks.TryGetValue(_eastChunkCoordinates, out asteroidList))
        {
            for (int j = 0; j < asteroidList.Count; j++)
            {
                if (CheckCollision(_allAsteroids[i].Position, asteroidList[j].Position))
                {
                    //Debug.Log("Asteroids " + _allAsteroids[i].Id + " and " + _allChunks[_allAsteroids[i].ChunkCoordinates][j].Id + " have been destroyed.");
                }
            }
        }

        if (_allChunks.TryGetValue(_westChunkCoordinates, out asteroidList))
        {
            for (int j = 0; j < asteroidList.Count; j++)
            {
                if (CheckCollision(_allAsteroids[i].Position, asteroidList[j].Position))
                {
                    //Debug.Log("Asteroids " + _allAsteroids[i].Id + " and " + _allChunks[_allAsteroids[i].ChunkCoordinates][j].Id + " have been destroyed.");
                }
            }
        }
    }

    /// <summary>
    /// TODO: Probably not needed, the chance of running into an undetected asteroid in a neighbouring *diagonal* chunk is very low.
    /// </summary>
    /// <param name="chunkCoordinates"></param>
    /// <param name="i"></param>
    private void CheckDiagonallyNeighbouringChunks(Vector2Int chunkCoordinates, int i)
    {
        List<Asteroid> asteroidList;

        _northEastChunkCoordinates = chunkCoordinates;
        _northEastChunkCoordinates.x = chunkCoordinates.x + 1;
        _northEastChunkCoordinates.y = chunkCoordinates.y + 1;

        _southEastChunkCoordinates = chunkCoordinates;
        _southEastChunkCoordinates.x = chunkCoordinates.x + 1;
        _southEastChunkCoordinates.y = chunkCoordinates.y - 1;

        _northWestChunkCoordinates = chunkCoordinates;
        _northWestChunkCoordinates.x = chunkCoordinates.x - 1;
        _northWestChunkCoordinates.y = chunkCoordinates.y + 1;

        _southWestChunkCoordinates = chunkCoordinates;
        _southWestChunkCoordinates.x = chunkCoordinates.x - 1;
        _southWestChunkCoordinates.y = chunkCoordinates.y - 1;


        if (_allChunks.TryGetValue(_northEastChunkCoordinates, out asteroidList))
        {
            for (int j = 0; j < asteroidList.Count; j++)
            {
                if (CheckCollision(_allAsteroids[i].Position, asteroidList[j].Position))
                {
                    //Debug.Log("Asteroids " + _allAsteroids[i].Id + " and " + _allChunks[_allAsteroids[i].ChunkCoordinates][j].Id + " have been destroyed.");
                }
            }
        }

        if (_allChunks.TryGetValue(_southEastChunkCoordinates, out asteroidList))
        {
            for (int j = 0; j < asteroidList.Count; j++)
            {
                if (CheckCollision(_allAsteroids[i].Position, asteroidList[j].Position))
                {
                    //Debug.Log("Asteroids " + _allAsteroids[i].Id + " and " + _allChunks[_allAsteroids[i].ChunkCoordinates][j].Id + " have been destroyed.");
                }
            }
        }

        if (_allChunks.TryGetValue(_northWestChunkCoordinates, out asteroidList))
        {
            for (int j = 0; j < asteroidList.Count; j++)
            {
                if (CheckCollision(_allAsteroids[i].Position, asteroidList[j].Position))
                {
                    //Debug.Log("Asteroids " + _allAsteroids[i].Id + " and " + _allChunks[_allAsteroids[i].ChunkCoordinates][j].Id + " have been destroyed.");
                }
            }
        }

        if (_allChunks.TryGetValue(_southWestChunkCoordinates, out asteroidList))
        {
            for (int j = 0; j < asteroidList.Count; j++)
            {
                if (CheckCollision(_allAsteroids[i].Position, asteroidList[j].Position))
                {
                    //Debug.Log("Asteroids " + _allAsteroids[i].Id + " and " + _allChunks[_allAsteroids[i].ChunkCoordinates][j].Id + " have been destroyed.");
                }
            }
        }

        //if (testCounter > 0)
        //{
        //    Debug.Log("Asteroida destroyed in DIAGONAL chunks.");
        //}
    }

    private bool CheckCollision(Vector2 asteroid1, Vector2 asteroid2)
    {
        if ((asteroid1 - asteroid2).magnitude < 0.3f)
        {
            return true;
        }
        return false;
    }
}
